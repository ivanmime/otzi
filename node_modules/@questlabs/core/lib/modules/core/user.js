"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.User = void 0;
const helperFunctions_1 = require("../../utils/helperFunctions");
const constants_1 = require("../../utils/constants");
class User {
    constructor(questSdk) {
        this.questSdk = questSdk;
    }
    createNewCustomUser(_a, options_1) {
        return __awaiter(this, arguments, void 0, function* ({ customPlatform, customUserId, entityId }, options) {
            try {
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ customPlatform, customUserId, entityId: defaultEntityId });
                const url = `/users/custom-ids`;
                const body = Object.assign({ customPlatform,
                    customUserId, entityId: defaultEntityId }, options === null || options === void 0 ? void 0 : options._body);
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    body,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                    queryParams: options === null || options === void 0 ? void 0 : options._queryParams,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    getUserDetailsForUserId() {
        return __awaiter(this, arguments, void 0, function* ({ forUserId } = {}, options) {
            try {
                const { userId, token } = this.questSdk.getUser();
                (0, helperFunctions_1.validateParams)({ userId, token });
                const queryParams = Object.assign({ userId: forUserId || userId }, options === null || options === void 0 ? void 0 : options._queryParams);
                const url = `/users/${forUserId || userId}`;
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.GET,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                    queryParams,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    getUserDetailsForEmail(_a, options_1) {
        return __awaiter(this, arguments, void 0, function* ({ email }, options) {
            try {
                const { userId, token } = this.questSdk.getUser();
                (0, helperFunctions_1.validateParams)({ email, userId, token });
                const url = `/users/email/${email}`;
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.GET,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                    queryParams: options === null || options === void 0 ? void 0 : options._queryParams,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    getUserDetailsForWalletAddress(_a, options_1) {
        return __awaiter(this, arguments, void 0, function* ({ walletAddress }, options) {
            try {
                const { userId, token } = this.questSdk.getUser();
                (0, helperFunctions_1.validateParams)({ userId, token, walletAddress });
                const url = `/users/address/${walletAddress}`;
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.GET,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                    queryParams: options === null || options === void 0 ? void 0 : options._queryParams,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    getConnectedUserSocials(_a, options_1) {
        return __awaiter(this, arguments, void 0, function* ({ entityId }, options) {
            try {
                const { userId, token } = this.questSdk.getUser();
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ userId, token, entityId: defaultEntityId });
                const url = `/entities/${defaultEntityId}/users/${userId}/connected-socials`;
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.GET,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                    queryParams: options === null || options === void 0 ? void 0 : options._queryParams,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    entitesForUser() {
        return __awaiter(this, arguments, void 0, function* ({ page, limit } = {}, options) {
            try {
                const { userId, token } = this.questSdk.getUser();
                (0, helperFunctions_1.validateParams)({ userId, token, page, limit });
                const url = `/users/${userId}/entities`;
                const queryParams = Object.assign({ page, limit }, options === null || options === void 0 ? void 0 : options._queryParams);
                return this.questSdk.makeRequest({ url, method: constants_1.HTTP_METHOD.GET, queryParams, headers: options === null || options === void 0 ? void 0 : options._headers });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    getAdminEntitiesForUser() {
        return __awaiter(this, arguments, void 0, function* ({ parentEntityId } = {}, options) {
            try {
                const { userId, token } = this.questSdk.getUser();
                (0, helperFunctions_1.validateParams)({ userId, token });
                const url = `/users/${userId}/admin-entities`;
                const queryParams = Object.assign(Object.assign({}, (parentEntityId && { parentEntityId })), options === null || options === void 0 ? void 0 : options._queryParams);
                return this.questSdk.makeRequest({ url, method: constants_1.HTTP_METHOD.GET, queryParams, headers: options === null || options === void 0 ? void 0 : options._headers });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    setSelectedAdminEntityId(_a, options_1) {
        return __awaiter(this, arguments, void 0, function* ({ entityId }, options) {
            try {
                const { userId, token } = this.questSdk.getUser();
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ userId, token, entityId: defaultEntityId });
                const url = `/users/${defaultEntityId}/admin-entities`;
                const body = Object.assign({ entityId }, options === null || options === void 0 ? void 0 : options._body);
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    body,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                    queryParams: options === null || options === void 0 ? void 0 : options._queryParams,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    setUserInfo(_a, options_1) {
        return __awaiter(this, arguments, void 0, function* ({ name, imageUrl, bannerUrl, location, expertise, goals, interests, about, currentWork, funFacts, role, sector, }, options) {
            try {
                const { userId, token } = this.questSdk.getUser();
                (0, helperFunctions_1.validateParams)({ userId, token });
                const url = `/users/${userId}`;
                const body = Object.assign({ name,
                    imageUrl,
                    bannerUrl,
                    location,
                    expertise,
                    goals,
                    interests,
                    about,
                    currentWork,
                    funFacts,
                    role,
                    sector }, options === null || options === void 0 ? void 0 : options._body);
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    body,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                    queryParams: options === null || options === void 0 ? void 0 : options._queryParams,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    sendOtpEmail(_a, options_1) {
        return __awaiter(this, arguments, void 0, function* ({ email, entityId }, options) {
            try {
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ email, entityId: defaultEntityId });
                const url = `/users/email-login/send-otp`;
                const body = Object.assign({ email, entityId: defaultEntityId }, options === null || options === void 0 ? void 0 : options._body);
                const queryParams = Object.assign({ entityId: defaultEntityId }, options === null || options === void 0 ? void 0 : options._queryParams);
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    body,
                    queryParams,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    verifyOtpEmail(_a, options_1) {
        return __awaiter(this, arguments, void 0, function* ({ email, entityId, otp, name }, options) {
            try {
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ email, entityId: defaultEntityId, otp });
                const url = `/users/email-login/verify-otp`;
                const body = Object.assign(Object.assign({ email, entityId: defaultEntityId, otp }, (name && { name })), options === null || options === void 0 ? void 0 : options._body);
                const response = yield this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    body,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                    queryParams: options === null || options === void 0 ? void 0 : options._queryParams,
                });
                if (response.success === true && response.userId && response.token) {
                    this.questSdk.setUser({
                        userId: response.userId,
                        token: response.token,
                    });
                }
                return response;
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    loginWithGoogle(_a, options_1) {
        return __awaiter(this, arguments, void 0, function* ({ code, redirectUri, entityId }, options) {
            try {
                (0, helperFunctions_1.validateParams)({ code, redirectUri, entityId });
                const url = `/users/google/login`;
                const body = Object.assign({ code, redirectUri, entityId }, options === null || options === void 0 ? void 0 : options._body);
                const response = yield this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    body,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                    queryParams: options === null || options === void 0 ? void 0 : options._queryParams,
                });
                if (response.success === true && response.userId && response.token) {
                    this.questSdk.setUser({
                        userId: response.userId,
                        token: response.token,
                    });
                }
                return response;
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    loginWithWallet(_a, options_1) {
        return __awaiter(this, arguments, void 0, function* ({ entityId, walletAddress, signature, token }, options) {
            try {
                (0, helperFunctions_1.validateParams)({ entityId, walletAddress, signature, token });
                const url = `/users/wallet/login`;
                const body = Object.assign({ entityId, walletAddress, signature, token }, options === null || options === void 0 ? void 0 : options._body);
                const response = yield this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    body,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                    queryParams: options === null || options === void 0 ? void 0 : options._queryParams,
                });
                if (response.success === true && response.userId && response.token) {
                    this.questSdk.setUser({
                        userId: response.userId,
                        token: response.token,
                    });
                }
                return response;
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    connectWallet(_a, options_1) {
        return __awaiter(this, arguments, void 0, function* ({ entityId, walletAddress, signature, token, userId }, options) {
            try {
                (0, helperFunctions_1.validateParams)({ entityId, walletAddress, signature, token, userId });
                const url = `/users/${userId}/wallet-connect`;
                const body = Object.assign({ entityId, walletAddress, signature, token }, options === null || options === void 0 ? void 0 : options._body);
                const queryParams = Object.assign({}, options === null || options === void 0 ? void 0 : options._queryParams);
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    body,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                    queryParams,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    loginWithExternalUserId(_a, options_1) {
        return __awaiter(this, arguments, void 0, function* ({ externalUserId, entityId, email, walletAddress, name, imageUrl }, options) {
            try {
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                (0, helperFunctions_1.validateParams)({ entityId: defaultEntityId, externalUserId });
                const url = `/users/external/login`;
                const body = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ externalUserId, entityId: defaultEntityId }, (email && { email })), (walletAddress && { walletAddress })), (name && { name })), (imageUrl && { imageUrl })), options === null || options === void 0 ? void 0 : options._body);
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    body,
                    queryParams: options === null || options === void 0 ? void 0 : options._queryParams,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
    // async loginWithExternalUserIdEncrypted(
    //     { externalUserId, entityId, email, walletAddress }: ILoginWithExternalUserId,
    //     options?: IPostRequestOptions
    // ): Promise<IVerifyOtpEmailResponse> {
    //     try {
    //         const defaultEntityId = entityId || this.questSdk.getEntityId();
    //         const { apiKey, apiSecret } = this.questSdk.getApiKeys();
    //         validateParams({ entityId: defaultEntityId, externalUserId, apiSecret });
    //         const dataToEncrypt = {
    //             externalUserId,
    //             entityId: defaultEntityId,
    //             ...(email && { email }),
    //             ...(walletAddress && { walletAddress }),
    //             apiKey,
    //         }
    //         const encryptedData = await this.encryptData(JSON.stringify(dataToEncrypt), apiSecret!);
    //         if (!encryptedData) {
    //             throw new Error('Encryption failed');
    //         }
    //         const url = `/users/external/login/encrypted`;
    //         const body = {
    //             entityId: defaultEntityId,
    //             encryptedData,
    //             ...options?._body,
    //         };
    //         return this.questSdk.makeRequest({
    //             url,
    //             method: HTTP_METHOD.POST,
    //             body,
    //             queryParams: options?._queryParams,
    //             headers: options?._headers,
    //         });
    //     } catch (error) {
    //         this.questSdk.captureSentryException(error);
    //         throw error;
    //     }
    // }
    refreshUserToken(_a, options_1) {
        return __awaiter(this, arguments, void 0, function* ({ refreshToken, entityId }, options) {
            try {
                const defaultEntityId = entityId || this.questSdk.getEntityId();
                const { userId, token } = this.questSdk.getUser();
                (0, helperFunctions_1.validateParams)({ entityId: defaultEntityId, refreshToken, token, userId });
                const url = `/entities/${defaultEntityId}/users/${userId}/refresh-token`;
                const body = Object.assign({ refreshToken }, options === null || options === void 0 ? void 0 : options._body);
                return this.questSdk.makeRequest({
                    url,
                    method: constants_1.HTTP_METHOD.POST,
                    queryParams: options === null || options === void 0 ? void 0 : options._queryParams,
                    body,
                    headers: options === null || options === void 0 ? void 0 : options._headers,
                });
            }
            catch (error) {
                this.questSdk.captureSentryException(error);
                throw error;
            }
        });
    }
}
exports.User = User;
