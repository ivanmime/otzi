{"version":3,"file":"triggers.js","sourceRoot":"","sources":["../../../src/pageActions/triggers.ts"],"names":[],"mappings":"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","sourcesContent":["import { Trigger } from '@amplitude/analytics-core/lib/esm/types/element-interactions';\n// Return which labeled events, if any, the element matches\nimport type { LabeledEvent } from '@amplitude/analytics-core/lib/esm/types/element-interactions';\nimport { ElementBasedTimestampedEvent, ElementBasedEvent } from 'src/helpers';\nimport { matchEventToFilter } from './matchEventToFilter';\n\n// groups labeled events by event type\n// skips any labeled events with malformed definitions or unexpected event_type\nexport const groupLabeledEventIdsByEventType = (labeledEvents?: LabeledEvent[] | null) => {\n  const groupedLabeledEvents = {\n    click: new Set<string>(),\n    change: new Set<string>(),\n  };\n  if (!labeledEvents) {\n    return groupedLabeledEvents;\n  }\n\n  for (const le of labeledEvents) {\n    try {\n      for (const def of le.definition) {\n        groupedLabeledEvents[def.event_type]?.add(le.id);\n      }\n    } catch (e) {\n      // Skip this labeled event if there is an error\n      console.warn('Skipping Labeled Event due to malformed definition', le?.id, e);\n    }\n  }\n  return groupedLabeledEvents;\n};\n\n// TODO: add tests\nexport const createLabeledEventToTriggerMap = (triggers: Trigger[]) => {\n  const labeledEventToTriggerMap = new Map<string, Trigger[]>();\n  for (const trigger of triggers) {\n    for (const condition of trigger.conditions) {\n      if (condition.type === 'LABELED_EVENT') {\n        const eventId = condition.match.eventId;\n        // Get existing triggers for this event ID or initialize empty array\n        let existingTriggers = labeledEventToTriggerMap.get(eventId);\n        if (!existingTriggers) {\n          existingTriggers = [];\n          labeledEventToTriggerMap.set(eventId, existingTriggers);\n        }\n        // Add current trigger to the list of triggers for this event ID\n        existingTriggers.push(trigger);\n      }\n    }\n  }\n  return labeledEventToTriggerMap;\n};\n\n/**\n * Matches an event to labeled events based on the event's properties.\n * The logic matches exactly what is supported by the query backend.\n * TODO: later pre-filter the labeled events based on URL first\n *\n * @param event - The event to match against labeled events\n * @param labeledEvents - Array of labeled events to match against\n * @returns Array of matching labeled events\n */\nexport const matchEventToLabeledEvents = (\n  event: ElementBasedTimestampedEvent<ElementBasedEvent>,\n  labeledEvents: LabeledEvent[],\n) => {\n  return labeledEvents.filter((le) => {\n    return le.definition.some((def) => {\n      return def.event_type === event.type && def.filters.every((filter) => matchEventToFilter(event, filter));\n    });\n  });\n};\n\nexport const matchLabeledEventsToTriggers = (labeledEvents: LabeledEvent[], leToTriggerMap: Map<string, Trigger[]>) => {\n  const matchingTriggers = new Set<Trigger>();\n  for (const le of labeledEvents) {\n    const triggers = leToTriggerMap.get(le.id);\n    if (triggers) {\n      triggers.forEach((trigger) => matchingTriggers.add(trigger));\n    }\n  }\n  return Array.from(matchingTriggers);\n};\n"]}